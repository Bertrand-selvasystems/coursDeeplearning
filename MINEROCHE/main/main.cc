/////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////// DECLARATION DES BIBLIOTHEQUES
/////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////
#include <math.h>
#include <string.h>
#include <time.h>

#include "constantes.h"
#include "donnees.h"
#include "driver/rmt_tx.h"
#include "esp_log.h"
#include "esp_timer.h"  // Pour utiliser esp_timer_get_time()
#include "freertos/FreeRTOS.h"
#include "freertos/queue.h"
#include "freertos/task.h"
#include "led.h"
#include "model.h"
#include "neurone.h"
#include "tasks.h"

extern "C" void app_main() {
  /////////////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////////////
  ///////////////////////// SETUP
  /////////////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////////////
  // Initialisation du réseau de neurones
  neurone_init();
  // inference
  float input_values[NUM_FEATURES];
  float output_values[1];

  /////////////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////////////
  ///////////////////////// TASKS
  /////////////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////////////
  xTaskCreate(led_task, "led_task", 8192, NULL, 5, NULL);  // il faut modifier la task qui gere les leds pour récupérer les précédentes prédictions
                                                           // // il faut faire les inferences : rajouter la task qui fait les inferences
                                                           // xTaskCreate(process_neural_network_task, "process_neural_network_task", 8192, NULL, 5, NULL);

  /////////////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////////////
  ///////////////////////// LOOP
  /////////////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////////////
  while (1) {
    // Initialisation du générateur de nombres aléatoires
    srand(time(NULL));

    // Sélection d'un échantillon aléatoire
    int index = rand() % NUM_SAMPLES;

    for (int i = 0; i < NUM_FEATURES; i++) {
      input_values[i] = X_test[index * NUM_FEATURES + i];
    }

    // Variable pour stocker la sortie du modèle
    float output;

    // Mesure du temps de calcul en millisecondes
    int64_t start_time = esp_timer_get_time();

    // Exécution de l'inférence
    neurone_inference(input_values, &output);

    // Calcul du temps écoulé en millisecondes
    int64_t end_time = esp_timer_get_time();                   // Temps de fin en microsecondes
    double elapsed_time_us = (double)(end_time - start_time);  // Temps écoulé en µs

    // Affichage des résultats
    printf("Échantillon sélectionné: %d\n", index);
    printf("Classification d'origine: %d\n", 1 - y_test[index]);
    if (abs(output - (1 - y_test[index])) < 0.5) {  // Comparaison après arrondi
      printf(ANSI_COLOR_GREEN "Résultat du modèle: %f\n" ANSI_COLOR_RESET, output);
    } else {
      printf(ANSI_COLOR_RED "Résultat du modèle: %f\n" ANSI_COLOR_RESET, output);
    }
    printf("Temps de calcul: %.2f µs\n\n", elapsed_time_us);
    vTaskDelay(pdMS_TO_TICKS(1000));
  }
}
